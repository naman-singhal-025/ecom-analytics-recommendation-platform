# Spring Application Name
spring.application.name=ecom-backend

# MongoDB Configuration
# Connects to the MongoDB instance running in Docker
# URI format: mongodb://<username>:<password>@<host>:<port>/<database>
spring.data.mongodb.uri=mongodb://admin:password@localhost:27017/ecommerce?authSource=admin
# could omit the spring.data.mongodb.database as it is already part of the URI, but it's fine to specify both.
spring.data.mongodb.database=ecommerce

# Kafka Configuration
# Points to the Kafka broker in the Docker network
spring.kafka.bootstrap-servers=localhost:9092

# Kafka Producer Configuration
# Specifies how to serialize the key and value of the Kafka message
# Key serializer: turns the Kafka message key into a string.
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
# Value serializer: converts the Java object (e.g., UserEvent) into JSON format
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer

# Kafka Consumer Configuration.  Commented properties are already defined in KafkaConsumerConfig.java

#spring.kafka.consumer.group-id=ecom-analytics-group
#spring.kafka.consumer.auto-offset-reset=earliest
#spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
#spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer

# Deserializer for JSON messages. Converts JSON strings back into Java objects. Not needed as we are using StringDeserializer for Kafka consumer in KafkaConsumerConfig.java
#spring.kafka.consumer.properties.spring.json.trusted.packages=com.ecommerce.ecom_backend.model

#spring.kafka.listener.concurrency=3

# Allows the application to start even if the topic doesn't exist yet.
#spring.kafka.listener.missing-topics-fatal=false

# Custom Properties
# Defines the Kafka topic for user events
kafka.topic.user-events=user-events

# Analytics Configuration
analytics.trending.timewindow.hours=24

# Elasticsearch Configuration
spring.elasticsearch.uris=http://localhost:9200

# Redis Configuration
spring.data.redis.host=localhost
spring.data.redis.port=6379

# PostgreSQL Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/ecommerce
spring.datasource.username=admin
spring.datasource.password=password

# When set to update, Hibernate will:
# Compare your JPA entities with the existing database schema
# Automatically add new tables, columns, or constraints that don't exist
# Never delete existing tables or columns (safe for existing data)
# Update schema on application startup
spring.jpa.hibernate.ddl-auto=update

# Allow Bean Definition Overriding
# This is necessary because we have multiple Spring Data modules (MongoDB, Elasticsearch)
# that may try to create beans with the same name.
spring.main.allow-bean-definition-overriding=true

# Show all logs: DEBUG, INFO, WARN, ERROR
logging.level.com.ecommerce.ecom_backend.services.AnalyticsConsumerService=DEBUG
# logging.level.org.springframework=INFO
# logging.level.com.ecommerce=DEBUG